package com.example.k5_iot_springboot.이론;

/*
* == 스프링 시큐리티(Spring Security, 보안) ==
* : Spring Framework 기반 애플리케이션에서 보안(인증, 인가, 권한)을 담당하는 보안 프레임워크
* - 다양한 어노테이션으로 CSRF 공격, 세션 고정 공격을 방어
* - 요청 헤더에 포함된 보안 처리도 가능
*
* 1. 인증(Authentication)
*   ex) 신분 확인
*   : 사용자가 누구인지 확인하는 과정, 신원 입증 과정
*   - 사용자가 로그인 기능을 통해 아이디, 비밀번호를 입력하면
*       , 해당 데이터들을 기반으로 사용자가 주장하는 인물인지 확인
*
* 2. 인가(Authorization)
*   ex) 권한 확인
*   : "인증된" 사용자가 특정 리소스(데이터)에 접근할 수 있는 권한인지 확인하는 과정
*   - 관리자만 특정 페이지에 접근하거나 특정 데이터를 호출할 수 있도록 설정
*
* cf) CSRF(Cross-Site Request Forgery)
*   : 자신(인증된 사용자)의 의지와는 상관없이 특정 웹 애플리케이션에
*       , 공격자가 원하는 요청을 보내도록 유도하는 웹 보안 취약점
*
* == Security 사용 목적 ==
* 1. 보안 기본기 자동 제공: 비밀번호 암호화, 세션/토큰 인증, 권한 체크, CSRF 보호 등
* 2. 표준화된 구조: 보안 코드가 일관되고 유지보수 쉬움
* 3. 유연한 확장성: 소셜 로그인, OAuth2, JWT, 2FA 등으로 확장 가능
* 4. 필수 방어막: 인증/인가 없는 서비스는 보안 취약
*
* == Security 선행 개념 ==
* 1. HTTP는 무상태(Stateless)
*   : 인터넷이 HTTP 통신은 기억력이 없음
*   - 서버는 이전 요청에 대한 사용자 정보를 기억하지 않음 (매번 로그인 정보를 다시 제출해야 함)
*
* 2. 세션(Session) VS 토큰(JWT)
*   1) 세션: 서버에 "누가 로그인 했는지" 기록. 클라이언트는 세션 ID 쿠키만 전달
*       - 서버가 로그인 상태를 기억
*   2) JWT: 서버는 토큰만 검증하고 별도의 저장소가 없어도 됨 (완전한 Stateless)
*       - 서명된 토큰으로 인증
*
* 3. 암호화 / 해싱
*   - 비밀번호 암호화 (문자열 그대로 저장하면 보안성 저하)
*       >> 해싱(Hashing): 긴 암호문으로 변환
*       >> 스프링 시큐리티는 주로 BCrypt 사용 (매번 다른 해시 결과로 만들어짐 > 안정성 향상)
*
* 4. Principal (주요한)
*   - "인증된" 사용자 정보 (아이디, 이메일 등)
*
* 5. Authority(권한), ROLE(역할)
*   - 역할에 따라 권한이 달라짐
*   >> 해당 요청 (해당 URL)은 권한 ROLE_ADMIN 만 들어갈 수 있음의 규칙을 정의하는 것
*
* 6. SecurityContext
*   : 현재 요청의 인증/권한 저장
*   - 현재의 사용자를 기록
*
* 7. Filter Chain
*   - 요청을 차례로 검사하는 필터 묶음
*   ex) '교문' > '복도' > '문앞'
*
* 8. UserDetailsService
*   - 사용자 조회 서비스 (DB에서 사용자 찾기)
*
* 9. PasswordEncoder
*   - 비밀전호 해시/검증기: BCrypt로 저장/비교
*
* 10. AuthenticationManager/Provider
*   - 인증 총괄/실행
* */

public class T_Security {
}
